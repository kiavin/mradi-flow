export default function pageTemplate(resource, type) {
  switch (type) {
    case 'create':
      return createPageTemplate(resource);
    case 'update':
      return updatePageTemplate(resource);
    case 'view':
      return viewPageTemplate(resource);
    case 'index':
      return indexPageTemplate(resource);
    default:
      throw new Error(`Unknown page type: ${type}`);
  }
}



export function indexPageTemplate(resource, tableColumns, moduleName, endPoints) {
  return `<script setup>
import { onMounted, ref, watch, getCurrentInstance, nextTick } from 'vue'
import { useRouter } from 'vue-router';
import Button from '~/themes/hopeui/components/atoms/button/BaseButton.vue'
import { useModalStore } from '~/omnicore/stores/modalStore.js'
import Form from './form.vue'

import DataTable from '~/themes/hopeui/components/organisms/DataTable.vue'

const { proxy } = getCurrentInstance()
const router = useRouter();

const modalStore = useModalStore()


const apiBaseUrl = \`/v1/${moduleName}/${formatResourceName(resource)}\`;
  
const { data, request, refresh, isLoading, error } = useApi(apiBaseUrl, 'GET', {}, false);


const tableData = ref({
  data: [],
  paginationData: {
    countOnPage: 0,
    currentPage: 1,
    perPage: 20,
    totalCount: 0,
    totalPages: 0,
    paginationLinks: {},
  },
})

const tableColumns = ${JSON.stringify(tableColumns)}

watch(data, () => {
  updateResponseData()
})
const updateResponseData = () => {
  if (data.value?.dataPayload) {
    tableData.value.data = Array.isArray(data.value.dataPayload.data)
      ? data.value.dataPayload.data
      : []
    tableData.value.paginationData = {
      countOnPage: data.value.dataPayload.countOnPage,
      currentPage: data.value.dataPayload.currentPage,
      perPage: data.value.dataPayload.perPage,
      totalCount: data.value.dataPayload.totalCount,
      totalPages: data.value.dataPayload.totalPages,
      paginationLinks: data.value.dataPayload.paginationLinks,
    }
    // console.log('Updated tableData:', tableData.value)
  }
}


//const handleView = (id) => {
// router.push({ name: '${moduleName}/${resource.toLowerCase()}/view', params: { id } });
//};

const handleView = async (id) => {
  modalStore.toggleModalUsage(true) // if you want to navigate to route set to false

  await nextTick(); // ensure store state is updated

  if (!modalStore.useModal) {
    router.push({ name: '${moduleName}/${resource.toLowerCase()}/view', params: { id } });
    return
  }

  const apiBaseUrl = \`/v1/${moduleName}/${formatResourceName(resource)}/\${id}\`;

  const { data, request, isLoading, error } = useApi(apiBaseUrl, 'GET', {}, true)

  await request()

  modalStore.openModal(
    Form,
    {
      formData: data.value?.dataPayload?.data || {},
      error,
      isLoading,
      readonly: true,
      hideSubmit: true,
    },
    'View ${resource}',
  )
}

//const handleEdit = (id) => {
//   router.push({ name: '${moduleName}/${resource.toLowerCase()}/update', params: { id } });
//}


const errors = ref({})

const handleEdit = async (id) => {
  errors.value = {}
  
  modalStore.toggleModalUsage(true) // if you want to navigate to route set to false

  await nextTick(); // ensure store state is updated

  if (!modalStore.useModal) {
    // Navigate to the update page
    router.push({ name: '${moduleName}/${resource.toLowerCase()}/update', params: { id } });
    return
  }

  // Fetch appointment data before opening the modal
  const apiBaseUrl = \`/v1/${moduleName}/${formatResourceName(resource)}/\${id}\`;
  const { data, request, isLoading, error } = useApi(apiBaseUrl, 'GET', {}, true)

  await request() // Fetch data before opening modal

  // Function to handle form submission (Update API Call)
  const handleSubmit = async (updatedData) => {
    const { request: updateData, error } = useApi(apiBaseUrl, 'PUT')
    await updateData(updatedData)
    if (error.value) {
      console.log('Error', error.value)
      errors.value = error.value // Assign the error object to errors
      return // Stop execution if error occurs
    }

    // Close modal on success
    modalStore.closeModal()

    // Show success message
    proxy.$showAlert({
      title: 'Success',
      icon: 'success',
      text: '${resource} Updated successfully',
      showConfirmButton: false,
      timer: 2000,
      timerProgressBar: true,
    })

    refresh()
  }

  // Open modal with Form component
  modalStore.openModal(
    Form,
    {
      formData: data.value?.dataPayload?.data || {},
      error: errors,
      isLoading,
      readonly: false, // Allow editing
      hideSubmit: false,
      onSubmit: handleSubmit, // Pass the submission function
    },
    'Edit ${resource}',
  )
}


const handleCreate = async() => {
  errors.value = {}
  modalStore.toggleModalUsage(true)

  await nextTick(); // ensure store state is updated

  if (!modalStore.useModal) {
    router.push({ name: '${moduleName}/${resource.toLowerCase()}/create' })
    return
  }

  // Define form submission handler
  const handleSubmit = async (newData) => {
    const apiBaseUrl = \`/v1/${moduleName}/${formatResourceName(resource)}\`;

    const { request: createData, error } = useApi(apiBaseUrl, 'POST')

    await createData(newData)

    if (error.value) {
      console.log('Error', error.value)
      errors.value = error.value // Assign errors to be passed to the form
      return
    }

    // Close modal and show success message
    modalStore.closeModal()

    proxy.$showAlert({
      title: 'Success',
      icon: 'success',
      text: '${resource} Created successfully',
      showConfirmButton: false,
      timer: 2000,
      timerProgressBar: true,
    })

    refresh()
  }

  // Open modal with Form component
  modalStore.openModal(
    Form,
    {
      formData: {}, // Empty form for creation
      error: errors, // Empty error object
      isLoading: false,
      readonly: false, // Allow input
      hideSubmit: false,
      onSubmit: handleSubmit, // Pass submission function
    },
    'Create ${resource}',
  )
}


const handleDelete = async (id, is_deleted) => {
   const action = is_deleted ? 'Restore' : 'Delete'

  const confirmationText = is_deleted
    ? 'You are about to restore this record. Do you want to proceed?'
    : 'You are about to delete this record. Do you want to proceed?'

  const result = await proxy.$showAlert({
    title: 'Are you sure?',
    text: confirmationText,
    icon: 'warning',
    showConfirmButton: true,
    confirmButtonText: \`Yes, \${action} it!\`,
    cancelButtonText: 'No, cancel!',
    confirmButtonColor: '#3085d6',
    cancelButtonColor: '#d33',
    reverseButtons: true,
  })
 
  if (result.isConfirmed) {
    try {
      // console.log('Deleting record with ID:', id)
     
      // autoFetch.value = false
      const { data, request, isLoading } = useApi(
        \`/v1/${moduleName}/${formatResourceName(resource)}/\${id}\`,
        'DELETE',
      )

      await request()

     if (data.value) {
        await proxy.$showAlert({
          title: \`\${action}d!\`,
          text: data.value?.toastPayload?.toastMessage || 'Record deleted successfully',
          icon: 'success',
          showCancelButton: false,
          showConfirmButton: false,
          timer: 1500,
        })
      }
    } catch (err) {
      console.error('Error deleting record:', error)
      await proxy.$showAlert({
        title: 'Error!',
        text: \`Error deleting record: \${error.value}\`,
        icon: 'error',
        showCancelButton: false,
      })
    } finally {
      await refresh()
    }
  } else {
    console.log('Deletion cancelled')
  }
  // await refresh()

}

const handleSearch = (query) => {
  request(null, {
    page: tableData.value.paginationData.currentPage,
    'per-page': tableData.value.paginationData.perPage,
    _search: query,
  })
}

const changePage = async (page) => {
  await request(null, { page, 'per-page': tableData.value.paginationData.perPage })
     
  updateResponseData()

  console.log('Page changed to: ', data.value)
}

const updatePerPage = async (perPage) => {
  tableData.value.paginationData.perPage = perPage
  await request(null, {
    page: tableData.value.paginationData.currentPage,
    'per-page': perPage,
  })
  updateResponseData()

}

onMounted(() => {
  request().then(() => {
    updateResponseData()
  })
})
</script>
<template>
  <div class="card p-3">
   <div class="row d-flex justify-content-between align-items-center mb-3">
      <div class="col-auto">
        <h1 class="h4 mt-2">List of ${resource}</h1>
      </div>
      <div class="col-auto mb-4">
        <Button type="submit" customClass="btn btn-primary" @click="handleCreate"> New ${resource} </Button>
      </div>
  <DataTable
        :data="tableData"
        :columns="tableColumns"
        :loading="isLoading"
        @edit="handleEdit"
        @search="handleSearch"
        @delete="handleDelete"
        @view="handleView"
        @changePage="changePage"
        @update:perPage="updatePerPage"
      />
  </div>
</div>


</template>
  
<style scoped></style>`;
}